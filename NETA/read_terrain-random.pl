#!/usr/bin/perl -w
#
# Script that implements an algorithm that places base stations randomly
# It first reads the terrain file generated by k-means algorithm
# and exports the new terrain file and a vector image
#
# by Dimitrios Zorbas (jim/at/students/cs/unipi/gr)
#
# Distributed under the GPLv3 (see LICENSE file)

use strict;
use GD::SVG;
use Math::Random;

my ($terrain_x, $terrain_y) = (1000 * 10, 1000 * 10); 	# 1km by 1km terrain

sub distance {
	my ($x1, $x2, $y1, $y2) = @_;
	return sqrt( ($x1-$x2)*($x1-$x2) + ($y1-$y2)*($y1-$y2) );
}

sub random_int {
	my $low = shift;
	my $high = shift;

	return Math::Random::random_uniform_integer(1, $low, $high);
}

(@ARGV==2) || die "usage: $0 <input_file> <output_file.svg>\n";

my $input_file = $ARGV[0];
my $output_file = $ARGV[1];

my $norm_x = 0;
my $norm_y = 0;

my @targets = ();
my @nodes = ();
my @sinks = ();
my @prev_sinks = ();
my $sensor_reading_radius = 0;
my $sensor_comm_radius = 0;
my %score = ();
my %tcoords = ();
my $stats;
my %coverage = ();

# COLLECT INFO FROM INPUT FILE

open(FH, "<$input_file") or
        die "Error: could not open terrain file $input_file\n";

while(<FH>){
        chomp;
	if (/^# stats: (.*)/){
		$stats = $1;
		my $one_pt_sz = 0;
		if ($stats =~ /sensor_sz=([0-9]+\.[0-9]+)m\^2/){
			$one_pt_sz = sqrt($1);
		}
		if ($stats =~ /sensor_reading_radius=([0-9]+\.[0-9]+)m/){
			$sensor_reading_radius = $1 / $one_pt_sz;
		}
		if ($stats =~ /sensor_comm_radius=([0-9]+\.[0-9]+)m/){
			$sensor_comm_radius = $1 / $one_pt_sz;
		}
	} elsif (/^# terrain map \[([0-9]+) x ([0-9]+)\]/){
		($norm_x, $norm_y) = ($1, $2);
	} elsif (/^# target coords: (.*)/){
		my $target_coord = $1;
		my @coords = split(/\] /, $target_coord);
		@targets = map { /([A-Z]+) \[([0-9]+) ([0-9]+)/; [$1, $2, $3]; } @coords;
	} elsif (/^# sensor coords: (.*)/){
		my $sensor_coord = $1;
		my @coords = split(/\] /, $sensor_coord);
		@nodes = map { /([0-9]+) \[([0-9]+) ([0-9]+)/; [$1, $2, $3]; } @coords;
	} elsif (/^# base station coords: (.*)/){
		my $bs_coord = $1;
		my @coords = split(/\] /, $bs_coord);
		@prev_sinks = map { /(S[0-9]+) \[([0-9]+) ([0-9]+)/; [$1, $2, $3]; } @coords;
	}

	next if (/^\#/); # skip comments
	chomp;
	my @input = split(/ /);
	my $point = shift @input;
	foreach my $s (@input){
		push (@{$coverage{$point}}, $s);
	}
}
close(FH);


### GENERATE RANDOM BS POSITIONS ###

my %bs_temp = ();
my $name = "S01";
for(my $i=1; $i<=scalar @prev_sinks; $i++){
	my ($x, $y) = (random_int(1, $norm_x), random_int(1, $norm_y));

	while (exists $bs_temp{$x}{$y}){
		($x, $y) = (random_int(1, $norm_x), random_int(1, $norm_y));
	}
	$bs_temp{$x}{$y} = 1;
        push(@sinks, [$name, $x, $y] );
	$name++;
}


### DISPLAY TERRAIN IN A SVG RESULT FILE ###

my ($display_x, $display_y) = (800, 800); # 800x800 pixel display pane
my $im = new GD::SVG::Image($display_x, $display_y);
my $white = $im->colorAllocate(255,255,255);
my $blue = $im->colorAllocate(0,0,255);
my $green = $im->colorAllocate(200,255,200);
my $black = $im->colorAllocate(0,0,0);
my $red = $im->colorAllocate(255,0,0);

foreach my $c (@sinks){
	my ($cid, $x, $y) = @$c;
	$im->filledRectangle( ($x * $display_x)/$norm_x-5, ($y * $display_y)/$norm_y-5,
		($x * $display_x)/$norm_x+5, ($y * $display_y)/$norm_y+5, $red);
}

foreach my $c (@prev_sinks){
	my ($cid, $x, $y) = @$c;
	$im->filledRectangle( ($x * $display_x)/$norm_x-5, ($y * $display_y)/$norm_y-5,
		($x * $display_x)/$norm_x+5, ($y * $display_y)/$norm_y+5, $black);
}

foreach my $t (@targets){
	my ($s, $x, $y) = @$t;
	($x, $y) = (int(($x * $display_x)/$norm_x), int(($y * $display_y)/$norm_y));

	$im->rectangle($x-5, $y-5, $x+5, $y+5, $red);
	$im->string(gdMediumBoldFont,$x-2,$y-20,$s,$blue);

foreach my $sensor (@nodes){
	my ($s, $x, $y) = @$sensor;
	($x, $y) = (int(($x * $display_x)/ $norm_x), int(($y * $display_y)/ $norm_y));

	$im->string(gdSmallFont,$x-2,$y-12,$s,$black);
	$im->filledRectangle($x-1, $y-1, $x+1, $y+1, $black);
}

open(FILEOUT, ">$output_file") or die "could not open file $output_file for writing!";
binmode FILEOUT;
print FILEOUT $im->svg;
close FILEOUT;


### PRINT STATISTICS ###

foreach my $t (sort keys %coverage){
	print "$t ";
	foreach my $s (@{$coverage{$t}}){
		print "$s ";
	}
	print "\n";
}

printf "# terrain map [%i x %i]\n", $norm_x, $norm_y;

print "# target coords:";
foreach my $t (@targets){
	my ($id, $x, $y) = @$t;
	printf " %s [%i %i]", $id, $x, $y;
}
print "\n";

print "# sensor coords:";
foreach my $n (@nodes){
	my ($id, $x, $y) = @$n;
	printf " %s [%i %i]", $id, $x, $y;
}
print "\n";

printf "# base station coords:";
foreach my $c (@sinks){
	my ($id, $x, $y) = @$c;
	printf " %s [%i %i]", $id, $x, $y;
}
print "\n";

print  	"# generated with: $0 ",join(" ",@ARGV),"\n";

print "# stats: $stats\n";

printf  "# %s\n", '$Id: read_terrain-random.pl 1639 2011-04-15 17:40:49Z jim $';
