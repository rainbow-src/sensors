#!/usr/bin/perl -w
#
# Script that implements NeTa algorithm
# It first reads the terrain file generated by k-means algorithm
# and exports the new terrain file and a vector image
#
# by Dimitrios Zorbas (jim/at/students/cs/unipi/gr)
#
# Distributed under the GPLv3 (see LICENSE file)

use strict;
use Graph;
use GD::SVG;
use Math::Trig;
use Algorithm::Cluster;

my ($terrain_x, $terrain_y) = (1000 * 10, 1000 * 10); 	# 1km by 1km terrain

sub distance {
	my ($x1, $x2, $y1, $y2) = @_;
	return sqrt( ($x1-$x2)*($x1-$x2) + ($y1-$y2)*($y1-$y2) );
}

(@ARGV==2) || die "usage: $0 <input_file> <output_file.svg>\n";

my $input_file = $ARGV[0];
my $output_file = $ARGV[1];

my $norm_x = 0;
my $norm_y = 0;

my @targets = ();
my @nodes = ();
my @sinks = ();
my @prev_sinks = ();
my $sensor_reading_radius = 0;
my $sensor_comm_radius = 0;
my %score = ();
my %tcoords = ();
my $stats;
my %coverage = ();

# COLLECT INFO FROM INPUT FILE

open(FH, "<$input_file") or
        die "Error: could not open terrain file $input_file\n";

while(<FH>){
        chomp;
	if (/^# stats: (.*)/){
		$stats = $1;
		my $one_pt_sz = 0;
		if ($stats =~ /sensor_sz=([0-9]+\.[0-9]+)m\^2/){
			$one_pt_sz = sqrt($1);
		}
		if ($stats =~ /sensor_reading_radius=([0-9]+\.[0-9]+)m/){
			$sensor_reading_radius = $1 / $one_pt_sz;
		}
		if ($stats =~ /sensor_comm_radius=([0-9]+\.[0-9]+)m/){
			$sensor_comm_radius = $1 / $one_pt_sz;
		}
	} elsif (/^# terrain map \[([0-9]+) x ([0-9]+)\]/){
		($norm_x, $norm_y) = ($1, $2);
	} elsif (/^# target coords: (.*)/){
		my $target_coord = $1;
		my @coords = split(/\] /, $target_coord);
		@targets = map { /([A-Z]+) \[([0-9]+) ([0-9]+)/; [$1, $2, $3]; } @coords;
	} elsif (/^# sensor coords: (.*)/){
		my $sensor_coord = $1;
		my @coords = split(/\] /, $sensor_coord);
		@nodes = map { /([0-9]+) \[([0-9]+) ([0-9]+)/; [$1, $2, $3]; } @coords;
	} elsif (/^# base station coords: (.*)/){
		my $bs_coord = $1;
		my @coords = split(/\] /, $bs_coord);
		@prev_sinks = map { /(S[0-9]+) \[([0-9]+) ([0-9]+)/; [$1, $2, $3]; } @coords;
	}

	next if (/^\#/); # skip comments
	chomp;
	my @input = split(/ /);
	my $point = shift @input;
	foreach my $s (@input){
		push (@{$coverage{$point}}, $s);
	}
}
close(FH);


### COMPUTE TARGET DISTANCES AND BS POSITIONS ###

my $graph = Graph::Undirected->new;
foreach my $t (@targets){
	my ($tid, $x, $y) = @$t;
	$tcoords{$tid} = [$x, $y];
	foreach my $tt (@targets){
		my ($ttid, $tx, $ty) = @$tt;
		next if ($tid eq $ttid);
		if (distance($x, $tx, $y, $ty) < 2 * $sensor_reading_radius){
			my $wt = 2*acos(distance($x, $tx, $y, $ty)/(2*$sensor_reading_radius))*$sensor_reading_radius**2 -
				sin(2*acos(distance($x, $tx, $y, $ty)/(2*$sensor_reading_radius)))*$sensor_reading_radius**2;
			$graph->add_weighted_edge($tid, $ttid, $wt);
		}else{
			$graph->add_vertex($tid) if (!$graph->has_vertex($tid));
			$graph->add_vertex($ttid) if (!$graph->has_vertex($ttid));
		}
	}
}

my $name = "S01";
my $temp_graph = $graph->deep_copy_graph;

my @checked = ();
while (scalar @sinks < scalar @prev_sinks){
	my @E = $temp_graph->edges;
	while ((scalar @E > 0) && (scalar @sinks < scalar @prev_sinks)){
		my $max_wt = 0;
		my @selected = ();
		foreach my $e (@E){
			my $wt = $temp_graph->get_edge_weight(@$e);
			if ($wt > $max_wt){
				$max_wt = $wt;
				@selected = @$e;
			}
		}
		my ($v1, $v2) = @selected;
		my ($x1, $y1) = @{$tcoords{$v1}};
		my ($x2, $y2) = @{$tcoords{$v2}};
		my @N1 = $graph->neighbours($v1);
		my @N2 = $graph->neighbours($v2);
		my ($sx, $sy) = (($x1+$x2), ($y1+$y2));
		my $a = 2;
		my @comp = ();
		foreach my $n (@N1){
			if (grep {$_ eq $n} @N2){
				my ($x, $y) = @{$tcoords{$n}};
				($sx, $sy) = ($sx+$x, $sy+$y);
				$a += 1;
				push (@comp, $n);
			}
		}
		($sx, $sy) = ($sx/$a, $sy/$a);
		my $score = 0;
		foreach my $sink (@sinks){
			my ($s, $x, $y) = @$sink;
			if (distance($sx, $x, $sy, $y) < 2*$sensor_reading_radius){
				$score += 1;
			}
		}
		if ($score == 0){
			push (@sinks, [$name, $sx, $sy]);
			$name++;
		}else{
			push (@checked, [$sx, $sy, $score]);
		}
		$temp_graph->delete_vertex($v1);
		$temp_graph->delete_vertex($v2);
		foreach my $n (@comp){
			$temp_graph->delete_vertex($n);
		}
		@E = $temp_graph->edges;
	}

	if (scalar @sinks < scalar @prev_sinks){
		my @V = $temp_graph->vertices;
		my @V_xy = ();
		my @mask1 = ();
		foreach my $v (@V){
			my ($x, $y) = @{$tcoords{$v}};
			push (@V_xy, [$x, $y]);
		}
		for (my $i = 0; $i < scalar @V; $i++){
	        	push(@mask1, [1, 1]);
		}

		my $weight1 = [1, 1];
		my $remaining = scalar @prev_sinks - scalar @sinks;
		if ((scalar @V_xy) < $remaining){
			$remaining = (scalar @V_xy);
		}
		my %parameters = (nclusters => $remaining, data => \@V_xy, mask => \@mask1, weight => $weight1, transpose => 0, npass => 10, method => 'a', dist => 'e', initialid => []);
		my ($clusters, $error, $found) = Algorithm::Cluster::kcluster(%parameters);
		if ($found == 0){
		        printf "No optimal solution found!\n";
	        	exit;
		}

		my %c_parameters = (data => \@V_xy, mask => \@mask1, weight => $weight1, clusterid => $clusters, method => 'a', transpose => 0);
		my ($cdata, $cmask) = Algorithm::Cluster::clustercentroids(%c_parameters);
		foreach my $c (@$cdata){
	        	my ($sx, $sy) = @$c;
			my $score = 0;
			foreach my $sink (@sinks){
				my ($s, $x, $y) = @$sink;
				if (distance($sx, $x, $sy, $y) < 2*$sensor_reading_radius){
					$score += 1;
				}
			}
			if ($score == 0){
				push (@sinks, [$name, $sx, $sy]);
				$name++;
			}else{
				push (@checked, [$sx, $sy, $score]);
			}
		}
	}

	my $i = scalar @prev_sinks - scalar @sinks;
	my @deleted_checked = ();
	for (my $j = 0; $j < $i; $j++){
		my $min_score = 99999999;
		my $selected_x = 0;
		my $selected_y = 0;
		my @new_checked = ();
		foreach my $s (@checked){
			my ($sx, $sy, $score) = @$s;
			next if (grep {$_ eq $sx*$sy} @deleted_checked);
			foreach my $sink (@sinks){
				my ($name, $x, $y) = @$sink;
				if (distance($sx, $x, $sy, $y) < 2*$sensor_reading_radius){
					$score += 1;
				}
			}
			push (@new_checked, [$sx, $sy, $score]);
		}


		foreach my $s (@new_checked){
			my ($sx, $sy, $score) = @$s;
			next if (grep {$_ eq $sx*$sy} @deleted_checked);
			if ($score < $min_score){
				$min_score = $score;
				$selected_x = $sx;
				$selected_y = $sy;
			}
		}
		push (@sinks, [$name, $selected_x, $selected_y]);
		push (@deleted_checked, $selected_x*$selected_y);
		$name++;
	}
}



### DISPLAY TERRAIN IN A SVG RESULT FILE ###

my ($display_x, $display_y) = (800, 800); # 800x800 pixel display pane
my $im = new GD::SVG::Image($display_x, $display_y);
my $white = $im->colorAllocate(255,255,255);
my $blue = $im->colorAllocate(0,0,255);
my $green = $im->colorAllocate(200,255,200);
my $black = $im->colorAllocate(0,0,0);
my $red = $im->colorAllocate(255,0,0);

foreach my $c (@sinks){
	my ($cid, $x, $y) = @$c;
	$im->filledRectangle( ($x * $display_x)/$norm_x-5, ($y * $display_y)/$norm_y-5,
		($x * $display_x)/$norm_x+5, ($y * $display_y)/$norm_y+5, $red);
}

foreach my $c (@prev_sinks){
	my ($cid, $x, $y) = @$c;
	$im->filledRectangle( ($x * $display_x)/$norm_x-5, ($y * $display_y)/$norm_y-5,
		($x * $display_x)/$norm_x+5, ($y * $display_y)/$norm_y+5, $black);
}

foreach my $t (@targets){
	my ($s, $x, $y) = @$t;
	($x, $y) = (int(($x * $display_x)/$norm_x), int(($y * $display_y)/$norm_y));

	$im->rectangle($x-5, $y-5, $x+5, $y+5, $red);
	$im->string(gdMediumBoldFont,$x-2,$y-20,$s,$blue);
}

my @E = $graph->edges;
foreach my $e (@E){
	my ($e1, $e2) = @$e;
	my ($x1, $y1) = ($tcoords{$e1}[0], $tcoords{$e1}[1]);
	($x1, $y1) = (int(($x1 * $display_x)/ $norm_x), int(($y1 * $display_y)/ $norm_y));
	my ($x2, $y2) = ($tcoords{$e2}[0], $tcoords{$e2}[1]);
	($x2, $y2) = (int(($x2 * $display_x)/ $norm_x), int(($y2 * $display_y)/ $norm_y));
	$im->line($x1, $y1, $x2, $y2, $green);
}


foreach my $sensor (@nodes){
	my ($s, $x, $y) = @$sensor;
	($x, $y) = (int(($x * $display_x)/ $norm_x), int(($y * $display_y)/ $norm_y));

	$im->string(gdSmallFont,$x-2,$y-12,$s,$black);
	$im->filledRectangle($x-1, $y-1, $x+1, $y+1, $black);
}

open(FILEOUT, ">$output_file") or die "could not open file $output_file for writing!";
binmode FILEOUT;
print FILEOUT $im->svg;
close FILEOUT;


### PRINT STATISTICS ###

foreach my $t (sort keys %coverage){
	print "$t ";
	foreach my $s (@{$coverage{$t}}){
		print "$s ";
	}
	print "\n";
}

printf "# terrain map [%i x %i]\n", $norm_x, $norm_y;

print "# target coords:";
foreach my $t (@targets){
	my ($id, $x, $y) = @$t;
	printf " %s [%i %i]", $id, $x, $y;
}
print "\n";

print "# sensor coords:";
foreach my $n (@nodes){
	my ($id, $x, $y) = @$n;
	printf " %s [%i %i]", $id, $x, $y;
}
print "\n";

printf "# base station coords:";
foreach my $c (@sinks){
	my ($id, $x, $y) = @$c;
	printf " %s [%i %i]", $id, $x, $y;
}
print "\n";

print  	"# generated with: $0 ",join(" ",@ARGV),"\n";

print "# stats: $stats\n";

printf  "# %s\n", '$Id: read_terrain-neta.pl 1639 2011-04-15 17:40:49Z jim $';
